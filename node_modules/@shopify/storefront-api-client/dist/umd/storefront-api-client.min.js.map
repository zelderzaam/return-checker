{"version":3,"file":"storefront-api-client.min.js","sources":["../../../graphql-client/dist/graphql-client/constants.mjs","../../../graphql-client/dist/graphql-client/utilities.mjs","../../../graphql-client/dist/graphql-client/http-fetch.mjs","../../../graphql-client/dist/graphql-client/graphql-client.mjs","../../../graphql-client/dist/api-client-utilities/validations.mjs","../../../graphql-client/dist/api-client-utilities/api-versions.mjs","../../../src/constants.ts","../../../src/storefront-api-client.ts","../../../src/validations.ts","../../../graphql-client/dist/api-client-utilities/utilities.mjs"],"sourcesContent":["const CLIENT = 'GraphQL Client';\nconst MIN_RETRIES = 0;\nconst MAX_RETRIES = 3;\nconst GQL_API_ERROR = \"An error occurred while fetching from the API. Review 'graphQLErrors' for details.\";\nconst UNEXPECTED_CONTENT_TYPE_ERROR = 'Response returned unexpected Content-Type:';\nconst NO_DATA_OR_ERRORS_ERROR = 'An unknown error has occurred. The API did not return a data object or any errors in its response.';\nconst CONTENT_TYPES = {\n    json: 'application/json',\n    multipart: 'multipart/mixed',\n};\nconst SDK_VARIANT_HEADER = 'X-SDK-Variant';\nconst SDK_VERSION_HEADER = 'X-SDK-Version';\nconst DEFAULT_SDK_VARIANT = 'shopify-graphql-client';\n// This is value is replaced with package.json version during rollup build process\nconst DEFAULT_CLIENT_VERSION = '1.4.1';\nconst RETRY_WAIT_TIME = 1000;\nconst RETRIABLE_STATUS_CODES = [429, 503];\nconst DEFER_OPERATION_REGEX = /@(defer)\\b/i;\nconst NEWLINE_SEPARATOR = '\\r\\n';\nconst BOUNDARY_HEADER_REGEX = /boundary=\"?([^=\";]+)\"?/i;\nconst HEADER_SEPARATOR = NEWLINE_SEPARATOR + NEWLINE_SEPARATOR;\n\nexport { BOUNDARY_HEADER_REGEX, CLIENT, CONTENT_TYPES, DEFAULT_CLIENT_VERSION, DEFAULT_SDK_VARIANT, DEFER_OPERATION_REGEX, GQL_API_ERROR, HEADER_SEPARATOR, MAX_RETRIES, MIN_RETRIES, NEWLINE_SEPARATOR, NO_DATA_OR_ERRORS_ERROR, RETRIABLE_STATUS_CODES, RETRY_WAIT_TIME, SDK_VARIANT_HEADER, SDK_VERSION_HEADER, UNEXPECTED_CONTENT_TYPE_ERROR };\n//# sourceMappingURL=constants.mjs.map\n","import { MIN_RETRIES, MAX_RETRIES, CLIENT } from './constants.mjs';\n\nfunction formatErrorMessage(message, client = CLIENT) {\n    return message.startsWith(`${client}`) ? message : `${client}: ${message}`;\n}\nfunction getErrorMessage(error) {\n    return error instanceof Error ? error.message : JSON.stringify(error);\n}\nfunction getErrorCause(error) {\n    return error instanceof Error && error.cause ? error.cause : undefined;\n}\nfunction combineErrors(dataArray) {\n    return dataArray.flatMap(({ errors }) => {\n        return errors ?? [];\n    });\n}\nfunction validateRetries({ client, retries, }) {\n    if (retries !== undefined &&\n        (typeof retries !== 'number' ||\n            retries < MIN_RETRIES ||\n            retries > MAX_RETRIES)) {\n        throw new Error(`${client}: The provided \"retries\" value (${retries}) is invalid - it cannot be less than ${MIN_RETRIES} or greater than ${MAX_RETRIES}`);\n    }\n}\nfunction getKeyValueIfValid(key, value) {\n    return value &&\n        (typeof value !== 'object' ||\n            Array.isArray(value) ||\n            (typeof value === 'object' && Object.keys(value).length > 0))\n        ? { [key]: value }\n        : {};\n}\nfunction buildDataObjectByPath(path, data) {\n    if (path.length === 0) {\n        return data;\n    }\n    const key = path.pop();\n    const newData = {\n        [key]: data,\n    };\n    if (path.length === 0) {\n        return newData;\n    }\n    return buildDataObjectByPath(path, newData);\n}\nfunction combineObjects(baseObject, newObject) {\n    return Object.keys(newObject || {}).reduce((acc, key) => {\n        if ((typeof newObject[key] === 'object' || Array.isArray(newObject[key])) &&\n            baseObject[key]) {\n            acc[key] = combineObjects(baseObject[key], newObject[key]);\n            return acc;\n        }\n        acc[key] = newObject[key];\n        return acc;\n    }, Array.isArray(baseObject) ? [...baseObject] : { ...baseObject });\n}\nfunction buildCombinedDataObject([initialDatum, ...remainingData]) {\n    return remainingData.reduce(combineObjects, { ...initialDatum });\n}\n\nexport { buildCombinedDataObject, buildDataObjectByPath, combineErrors, formatErrorMessage, getErrorCause, getErrorMessage, getKeyValueIfValid, validateRetries };\n//# sourceMappingURL=utilities.mjs.map\n","import { CLIENT, RETRY_WAIT_TIME, RETRIABLE_STATUS_CODES } from './constants.mjs';\nimport { formatErrorMessage, getErrorMessage } from './utilities.mjs';\n\nfunction generateHttpFetch({ clientLogger, customFetchApi = fetch, client = CLIENT, defaultRetryWaitTime = RETRY_WAIT_TIME, retriableCodes = RETRIABLE_STATUS_CODES, }) {\n    const httpFetch = async (requestParams, count, maxRetries) => {\n        const nextCount = count + 1;\n        const maxTries = maxRetries + 1;\n        let response;\n        try {\n            response = await customFetchApi(...requestParams);\n            clientLogger({\n                type: 'HTTP-Response',\n                content: {\n                    requestParams,\n                    response,\n                },\n            });\n            if (!response.ok &&\n                retriableCodes.includes(response.status) &&\n                nextCount <= maxTries) {\n                throw new Error();\n            }\n            const deprecationNotice = response?.headers.get('X-Shopify-API-Deprecated-Reason') || '';\n            if (deprecationNotice) {\n                clientLogger({\n                    type: 'HTTP-Response-GraphQL-Deprecation-Notice',\n                    content: {\n                        requestParams,\n                        deprecationNotice,\n                    },\n                });\n            }\n            return response;\n        }\n        catch (error) {\n            if (nextCount <= maxTries) {\n                const retryAfter = response?.headers.get('Retry-After');\n                await sleep(retryAfter ? parseInt(retryAfter, 10) : defaultRetryWaitTime);\n                clientLogger({\n                    type: 'HTTP-Retry',\n                    content: {\n                        requestParams,\n                        lastResponse: response,\n                        retryAttempt: count,\n                        maxRetries,\n                    },\n                });\n                return httpFetch(requestParams, nextCount, maxRetries);\n            }\n            throw new Error(formatErrorMessage(`${maxRetries > 0\n                ? `Attempted maximum number of ${maxRetries} network retries. Last message - `\n                : ''}${getErrorMessage(error)}`, client));\n        }\n    };\n    return httpFetch;\n}\nasync function sleep(waitTime) {\n    return new Promise((resolve) => setTimeout(resolve, waitTime));\n}\n\nexport { generateHttpFetch };\n//# sourceMappingURL=http-fetch.mjs.map\n","import { generateHttpFetch } from './http-fetch.mjs';\nimport { CLIENT, SDK_VARIANT_HEADER, SDK_VERSION_HEADER, DEFAULT_SDK_VARIANT, DEFAULT_CLIENT_VERSION, DEFER_OPERATION_REGEX, UNEXPECTED_CONTENT_TYPE_ERROR, CONTENT_TYPES, BOUNDARY_HEADER_REGEX, GQL_API_ERROR, NO_DATA_OR_ERRORS_ERROR, RETRY_WAIT_TIME, HEADER_SEPARATOR } from './constants.mjs';\nimport { validateRetries, formatErrorMessage, getErrorCause, getKeyValueIfValid, getErrorMessage, combineErrors, buildCombinedDataObject, buildDataObjectByPath } from './utilities.mjs';\n\nfunction createGraphQLClient({ headers, url, customFetchApi = fetch, retries = 0, logger, }) {\n    validateRetries({ client: CLIENT, retries });\n    const config = {\n        headers,\n        url,\n        retries,\n    };\n    const clientLogger = generateClientLogger(logger);\n    const httpFetch = generateHttpFetch({\n        customFetchApi,\n        clientLogger,\n        defaultRetryWaitTime: RETRY_WAIT_TIME,\n    });\n    const fetchFn = generateFetch(httpFetch, config);\n    const request = generateRequest(fetchFn);\n    const requestStream = generateRequestStream(fetchFn);\n    return {\n        config,\n        fetch: fetchFn,\n        request,\n        requestStream,\n    };\n}\nfunction generateClientLogger(logger) {\n    return (logContent) => {\n        if (logger) {\n            logger(logContent);\n        }\n    };\n}\nasync function processJSONResponse(response) {\n    const { errors, data, extensions } = await response.json();\n    return {\n        ...getKeyValueIfValid('data', data),\n        ...getKeyValueIfValid('extensions', extensions),\n        headers: response.headers,\n        ...(errors || !data\n            ? {\n                errors: {\n                    networkStatusCode: response.status,\n                    message: formatErrorMessage(errors ? GQL_API_ERROR : NO_DATA_OR_ERRORS_ERROR),\n                    ...getKeyValueIfValid('graphQLErrors', errors),\n                    response,\n                },\n            }\n            : {}),\n    };\n}\nfunction generateFetch(httpFetch, { url, headers, retries }) {\n    return async (operation, options = {}) => {\n        const { variables, headers: overrideHeaders, url: overrideUrl, retries: overrideRetries, keepalive, signal, } = options;\n        const body = JSON.stringify({\n            query: operation,\n            variables,\n        });\n        validateRetries({ client: CLIENT, retries: overrideRetries });\n        const flatHeaders = Object.entries({\n            ...headers,\n            ...overrideHeaders,\n        }).reduce((headers, [key, value]) => {\n            headers[key] = Array.isArray(value) ? value.join(', ') : value.toString();\n            return headers;\n        }, {});\n        if (!flatHeaders[SDK_VARIANT_HEADER] && !flatHeaders[SDK_VERSION_HEADER]) {\n            flatHeaders[SDK_VARIANT_HEADER] = DEFAULT_SDK_VARIANT;\n            flatHeaders[SDK_VERSION_HEADER] = DEFAULT_CLIENT_VERSION;\n        }\n        const fetchParams = [\n            overrideUrl ?? url,\n            {\n                method: 'POST',\n                headers: flatHeaders,\n                body,\n                signal,\n                keepalive,\n            },\n        ];\n        return httpFetch(fetchParams, 1, overrideRetries ?? retries);\n    };\n}\nfunction generateRequest(fetchFn) {\n    return async (...props) => {\n        if (DEFER_OPERATION_REGEX.test(props[0])) {\n            throw new Error(formatErrorMessage('This operation will result in a streamable response - use requestStream() instead.'));\n        }\n        let response = null;\n        try {\n            response = await fetchFn(...props);\n            const { status, statusText } = response;\n            const contentType = response.headers.get('content-type') || '';\n            if (!response.ok) {\n                return {\n                    errors: {\n                        networkStatusCode: status,\n                        message: formatErrorMessage(statusText),\n                        response,\n                    },\n                };\n            }\n            if (!contentType.includes(CONTENT_TYPES.json)) {\n                return {\n                    errors: {\n                        networkStatusCode: status,\n                        message: formatErrorMessage(`${UNEXPECTED_CONTENT_TYPE_ERROR} ${contentType}`),\n                        response,\n                    },\n                };\n            }\n            return await processJSONResponse(response);\n        }\n        catch (error) {\n            return {\n                errors: {\n                    message: getErrorMessage(error),\n                    ...(response == null\n                        ? {}\n                        : {\n                            networkStatusCode: response.status,\n                            response,\n                        }),\n                },\n            };\n        }\n    };\n}\nasync function* getStreamBodyIterator(response) {\n    const decoder = new TextDecoder();\n    // Response body is an async iterator\n    if (response.body[Symbol.asyncIterator]) {\n        for await (const chunk of response.body) {\n            yield decoder.decode(chunk);\n        }\n    }\n    else {\n        const reader = response.body.getReader();\n        let readResult;\n        try {\n            while (!(readResult = await reader.read()).done) {\n                yield decoder.decode(readResult.value);\n            }\n        }\n        finally {\n            reader.cancel();\n        }\n    }\n}\nfunction readStreamChunk(streamBodyIterator, boundary) {\n    return {\n        async *[Symbol.asyncIterator]() {\n            try {\n                let buffer = '';\n                for await (const textChunk of streamBodyIterator) {\n                    buffer += textChunk;\n                    if (buffer.indexOf(boundary) > -1) {\n                        const lastBoundaryIndex = buffer.lastIndexOf(boundary);\n                        const fullResponses = buffer.slice(0, lastBoundaryIndex);\n                        const chunkBodies = fullResponses\n                            .split(boundary)\n                            .filter((chunk) => chunk.trim().length > 0)\n                            .map((chunk) => {\n                            const body = chunk\n                                .slice(chunk.indexOf(HEADER_SEPARATOR) + HEADER_SEPARATOR.length)\n                                .trim();\n                            return body;\n                        });\n                        if (chunkBodies.length > 0) {\n                            yield chunkBodies;\n                        }\n                        buffer = buffer.slice(lastBoundaryIndex + boundary.length);\n                        if (buffer.trim() === `--`) {\n                            buffer = '';\n                        }\n                    }\n                }\n            }\n            catch (error) {\n                throw new Error(`Error occured while processing stream payload - ${getErrorMessage(error)}`);\n            }\n        },\n    };\n}\nfunction createJsonResponseAsyncIterator(response) {\n    return {\n        async *[Symbol.asyncIterator]() {\n            const processedResponse = await processJSONResponse(response);\n            yield {\n                ...processedResponse,\n                hasNext: false,\n            };\n        },\n    };\n}\nfunction getResponseDataFromChunkBodies(chunkBodies) {\n    return chunkBodies\n        .map((value) => {\n        try {\n            return JSON.parse(value);\n        }\n        catch (error) {\n            throw new Error(`Error in parsing multipart response - ${getErrorMessage(error)}`);\n        }\n    })\n        .map((payload) => {\n        const { data, incremental, hasNext, extensions, errors } = payload;\n        // initial data chunk\n        if (!incremental) {\n            return {\n                data: data || {},\n                ...getKeyValueIfValid('errors', errors),\n                ...getKeyValueIfValid('extensions', extensions),\n                hasNext,\n            };\n        }\n        // subsequent data chunks\n        const incrementalArray = incremental.map(({ data, path, errors }) => {\n            return {\n                data: data && path ? buildDataObjectByPath(path, data) : {},\n                ...getKeyValueIfValid('errors', errors),\n            };\n        });\n        return {\n            data: incrementalArray.length === 1\n                ? incrementalArray[0].data\n                : buildCombinedDataObject([\n                    ...incrementalArray.map(({ data }) => data),\n                ]),\n            ...getKeyValueIfValid('errors', combineErrors(incrementalArray)),\n            hasNext,\n        };\n    });\n}\nfunction validateResponseData(responseErrors, combinedData) {\n    if (responseErrors.length > 0) {\n        throw new Error(GQL_API_ERROR, {\n            cause: {\n                graphQLErrors: responseErrors,\n            },\n        });\n    }\n    if (Object.keys(combinedData).length === 0) {\n        throw new Error(NO_DATA_OR_ERRORS_ERROR);\n    }\n}\nfunction createMultipartResponseAsyncInterator(response, responseContentType) {\n    const boundaryHeader = (responseContentType ?? '').match(BOUNDARY_HEADER_REGEX);\n    const boundary = `--${boundaryHeader ? boundaryHeader[1] : '-'}`;\n    if (!response.body?.getReader &&\n        !response.body?.[Symbol.asyncIterator]) {\n        throw new Error('API multipart response did not return an iterable body', {\n            cause: response,\n        });\n    }\n    const streamBodyIterator = getStreamBodyIterator(response);\n    let combinedData = {};\n    let responseExtensions;\n    return {\n        async *[Symbol.asyncIterator]() {\n            try {\n                let streamHasNext = true;\n                for await (const chunkBodies of readStreamChunk(streamBodyIterator, boundary)) {\n                    const responseData = getResponseDataFromChunkBodies(chunkBodies);\n                    responseExtensions =\n                        responseData.find((datum) => datum.extensions)?.extensions ??\n                            responseExtensions;\n                    const responseErrors = combineErrors(responseData);\n                    combinedData = buildCombinedDataObject([\n                        combinedData,\n                        ...responseData.map(({ data }) => data),\n                    ]);\n                    streamHasNext = responseData.slice(-1)[0].hasNext;\n                    validateResponseData(responseErrors, combinedData);\n                    yield {\n                        ...getKeyValueIfValid('data', combinedData),\n                        ...getKeyValueIfValid('extensions', responseExtensions),\n                        hasNext: streamHasNext,\n                    };\n                }\n                if (streamHasNext) {\n                    throw new Error(`Response stream terminated unexpectedly`);\n                }\n            }\n            catch (error) {\n                const cause = getErrorCause(error);\n                yield {\n                    ...getKeyValueIfValid('data', combinedData),\n                    ...getKeyValueIfValid('extensions', responseExtensions),\n                    errors: {\n                        message: formatErrorMessage(getErrorMessage(error)),\n                        networkStatusCode: response.status,\n                        ...getKeyValueIfValid('graphQLErrors', cause?.graphQLErrors),\n                        response,\n                    },\n                    hasNext: false,\n                };\n            }\n        },\n    };\n}\nfunction generateRequestStream(fetchFn) {\n    return async (...props) => {\n        if (!DEFER_OPERATION_REGEX.test(props[0])) {\n            throw new Error(formatErrorMessage('This operation does not result in a streamable response - use request() instead.'));\n        }\n        try {\n            const response = await fetchFn(...props);\n            const { statusText } = response;\n            if (!response.ok) {\n                throw new Error(statusText, { cause: response });\n            }\n            const responseContentType = response.headers.get('content-type') || '';\n            switch (true) {\n                case responseContentType.includes(CONTENT_TYPES.json):\n                    return createJsonResponseAsyncIterator(response);\n                case responseContentType.includes(CONTENT_TYPES.multipart):\n                    return createMultipartResponseAsyncInterator(response, responseContentType);\n                default:\n                    throw new Error(`${UNEXPECTED_CONTENT_TYPE_ERROR} ${responseContentType}`, { cause: response });\n            }\n        }\n        catch (error) {\n            return {\n                async *[Symbol.asyncIterator]() {\n                    const response = getErrorCause(error);\n                    yield {\n                        errors: {\n                            message: formatErrorMessage(getErrorMessage(error)),\n                            ...getKeyValueIfValid('networkStatusCode', response?.status),\n                            ...getKeyValueIfValid('response', response),\n                        },\n                        hasNext: false,\n                    };\n                },\n            };\n        }\n    };\n}\n\nexport { createGraphQLClient, generateClientLogger };\n//# sourceMappingURL=graphql-client.mjs.map\n","function validateDomainAndGetStoreUrl({ client, storeDomain, }) {\n    try {\n        if (!storeDomain || typeof storeDomain !== 'string') {\n            throw new Error();\n        }\n        const trimmedDomain = storeDomain.trim();\n        const protocolUrl = trimmedDomain.match(/^https?:/)\n            ? trimmedDomain\n            : `https://${trimmedDomain}`;\n        const url = new URL(protocolUrl);\n        url.protocol = 'https';\n        return url.origin;\n    }\n    catch (error) {\n        throw new Error(`${client}: a valid store domain (\"${storeDomain}\") must be provided`, { cause: error });\n    }\n}\nfunction validateApiVersion({ client, currentSupportedApiVersions, apiVersion, logger, }) {\n    const versionError = `${client}: the provided apiVersion (\"${apiVersion}\")`;\n    const supportedVersion = `Currently supported API versions: ${currentSupportedApiVersions.join(', ')}`;\n    if (!apiVersion || typeof apiVersion !== 'string') {\n        throw new Error(`${versionError} is invalid. ${supportedVersion}`);\n    }\n    const trimmedApiVersion = apiVersion.trim();\n    if (!currentSupportedApiVersions.includes(trimmedApiVersion)) {\n        if (logger) {\n            logger({\n                type: 'Unsupported_Api_Version',\n                content: {\n                    apiVersion,\n                    supportedApiVersions: currentSupportedApiVersions,\n                },\n            });\n        }\n        else {\n            console.warn(`${versionError} is likely deprecated or not supported. ${supportedVersion}`);\n        }\n    }\n}\n\nexport { validateApiVersion, validateDomainAndGetStoreUrl };\n//# sourceMappingURL=validations.mjs.map\n","function getQuarterMonth(quarter) {\n    const month = quarter * 3 - 2;\n    return month === 10 ? month : `0${month}`;\n}\nfunction getPrevousVersion(year, quarter, nQuarter) {\n    const versionQuarter = quarter - nQuarter;\n    if (versionQuarter <= 0) {\n        return `${year - 1}-${getQuarterMonth(versionQuarter + 4)}`;\n    }\n    return `${year}-${getQuarterMonth(versionQuarter)}`;\n}\nfunction getCurrentApiVersion() {\n    const date = new Date();\n    const month = date.getUTCMonth();\n    const year = date.getUTCFullYear();\n    const quarter = Math.floor(month / 3 + 1);\n    return {\n        year,\n        quarter,\n        version: `${year}-${getQuarterMonth(quarter)}`,\n    };\n}\nfunction getCurrentSupportedApiVersions() {\n    const { year, quarter, version: currentVersion } = getCurrentApiVersion();\n    const nextVersion = quarter === 4\n        ? `${year + 1}-01`\n        : `${year}-${getQuarterMonth(quarter + 1)}`;\n    return [\n        getPrevousVersion(year, quarter, 3),\n        getPrevousVersion(year, quarter, 2),\n        getPrevousVersion(year, quarter, 1),\n        currentVersion,\n        nextVersion,\n        'unstable',\n    ];\n}\n\nexport { getCurrentApiVersion, getCurrentSupportedApiVersions };\n//# sourceMappingURL=api-versions.mjs.map\n","export const DEFAULT_CONTENT_TYPE = 'application/json';\nexport const DEFAULT_SDK_VARIANT = 'storefront-api-client';\n// This is value is replaced with package.json version during rollup build process\nexport const DEFAULT_CLIENT_VERSION = 'ROLLUP_REPLACE_CLIENT_VERSION';\n\nexport const PUBLIC_ACCESS_TOKEN_HEADER = 'X-Shopify-Storefront-Access-Token';\nexport const PRIVATE_ACCESS_TOKEN_HEADER = 'Shopify-Storefront-Private-Token';\nexport const SDK_VARIANT_HEADER = 'X-SDK-Variant';\nexport const SDK_VERSION_HEADER = 'X-SDK-Version';\nexport const SDK_VARIANT_SOURCE_HEADER = 'X-SDK-Variant-Source';\n\nexport const CLIENT = 'Storefront API Client';\n","import {\n  createGraphQLClient,\n  getCurrentSupportedApiVersions,\n  validateDomainAndGetStoreUrl,\n  validateApiVersion,\n  generateGetGQLClientParams,\n  generateGetHeaders,\n} from '@shopify/graphql-client';\n\nimport {\n  StorefrontApiClientOptions,\n  StorefrontApiClient,\n  StorefrontApiClientConfig,\n  StorefrontOperations,\n} from './types';\nimport {\n  DEFAULT_SDK_VARIANT,\n  DEFAULT_CLIENT_VERSION,\n  SDK_VARIANT_HEADER,\n  SDK_VARIANT_SOURCE_HEADER,\n  SDK_VERSION_HEADER,\n  DEFAULT_CONTENT_TYPE,\n  PUBLIC_ACCESS_TOKEN_HEADER,\n  PRIVATE_ACCESS_TOKEN_HEADER,\n  CLIENT,\n} from './constants';\nimport {\n  validateRequiredAccessTokens,\n  validatePrivateAccessTokenUsage,\n} from './validations';\n\nexport function createStorefrontApiClient({\n  storeDomain,\n  apiVersion,\n  publicAccessToken,\n  privateAccessToken,\n  clientName,\n  retries = 0,\n  customFetchApi,\n  logger,\n}: StorefrontApiClientOptions): StorefrontApiClient {\n  const currentSupportedApiVersions = getCurrentSupportedApiVersions();\n\n  const storeUrl = validateDomainAndGetStoreUrl({\n    client: CLIENT,\n    storeDomain,\n  });\n\n  const baseApiVersionValidationParams = {\n    client: CLIENT,\n    currentSupportedApiVersions,\n    logger,\n  };\n\n  validateApiVersion({...baseApiVersionValidationParams, apiVersion});\n  validateRequiredAccessTokens(publicAccessToken, privateAccessToken);\n  validatePrivateAccessTokenUsage(privateAccessToken);\n\n  const apiUrlFormatter = generateApiUrlFormatter(\n    storeUrl,\n    apiVersion,\n    baseApiVersionValidationParams,\n  );\n\n  const config: StorefrontApiClientConfig = {\n    storeDomain: storeUrl,\n    apiVersion,\n    ...(publicAccessToken\n      ? {publicAccessToken}\n      : {\n          privateAccessToken: privateAccessToken!,\n        }),\n    headers: {\n      'Content-Type': DEFAULT_CONTENT_TYPE,\n      Accept: DEFAULT_CONTENT_TYPE,\n      [SDK_VARIANT_HEADER]: DEFAULT_SDK_VARIANT,\n      [SDK_VERSION_HEADER]: DEFAULT_CLIENT_VERSION,\n      ...(clientName ? {[SDK_VARIANT_SOURCE_HEADER]: clientName} : {}),\n      ...(publicAccessToken\n        ? {[PUBLIC_ACCESS_TOKEN_HEADER]: publicAccessToken}\n        : {[PRIVATE_ACCESS_TOKEN_HEADER]: privateAccessToken!}),\n    },\n    apiUrl: apiUrlFormatter(),\n    clientName,\n  };\n\n  const graphqlClient = createGraphQLClient({\n    headers: config.headers,\n    url: config.apiUrl,\n    retries,\n    customFetchApi,\n    logger,\n  });\n\n  const getHeaders = generateGetHeaders(config);\n  const getApiUrl = generateGetApiUrl(config, apiUrlFormatter);\n\n  const getGQLClientParams = generateGetGQLClientParams<StorefrontOperations>({\n    getHeaders,\n    getApiUrl,\n  });\n\n  const client: StorefrontApiClient = {\n    config,\n    getHeaders,\n    getApiUrl,\n    fetch: (...props) => {\n      return graphqlClient.fetch(...getGQLClientParams(...props));\n    },\n    request: (...props) => {\n      return graphqlClient.request(...getGQLClientParams(...props));\n    },\n    requestStream: (...props) => {\n      return graphqlClient.requestStream(...getGQLClientParams(...props));\n    },\n  };\n\n  return Object.freeze(client);\n}\n\nfunction generateApiUrlFormatter(\n  storeUrl: string,\n  defaultApiVersion: string,\n  baseApiVersionValidationParams: Omit<\n    Parameters<typeof validateApiVersion>[0],\n    'apiVersion'\n  >,\n) {\n  return (apiVersion?: string) => {\n    if (apiVersion) {\n      validateApiVersion({\n        ...baseApiVersionValidationParams,\n        apiVersion,\n      });\n    }\n\n    const urlApiVersion = (apiVersion ?? defaultApiVersion).trim();\n\n    return `${storeUrl}/api/${urlApiVersion}/graphql.json`;\n  };\n}\n\nfunction generateGetApiUrl(\n  config: StorefrontApiClientConfig,\n  apiUrlFormatter: (version?: string) => string,\n): StorefrontApiClient['getApiUrl'] {\n  return (propApiVersion?: string) => {\n    return propApiVersion ? apiUrlFormatter(propApiVersion) : config.apiUrl;\n  };\n}\n","import {CLIENT} from './constants';\n\nexport function validatePrivateAccessTokenUsage(\n  privateAccessToken: string | undefined,\n) {\n  if (privateAccessToken && typeof window !== 'undefined') {\n    throw new Error(\n      `${CLIENT}: private access tokens and headers should only be used in a server-to-server implementation. Use the public API access token in nonserver environments.`,\n    );\n  }\n}\n\nexport function validateRequiredAccessTokens(\n  publicAccessToken: string | undefined,\n  privateAccessToken: string | undefined,\n) {\n  if (!publicAccessToken && !privateAccessToken) {\n    throw new Error(\n      `${CLIENT}: a public or private access token must be provided`,\n    );\n  }\n\n  if (publicAccessToken && privateAccessToken) {\n    throw new Error(\n      `${CLIENT}: only provide either a public or private access token`,\n    );\n  }\n}\n","function generateGetHeaders(config) {\n    return (customHeaders) => {\n        return { ...(customHeaders ?? {}), ...config.headers };\n    };\n}\nfunction generateGetGQLClientParams({ getHeaders, getApiUrl }) {\n    return (operation, options) => {\n        const props = [operation];\n        if (options && Object.keys(options).length > 0) {\n            const { variables, apiVersion: propApiVersion, headers, retries, signal, } = options;\n            props.push({\n                ...(variables ? { variables } : {}),\n                ...(headers ? { headers: getHeaders(headers) } : {}),\n                ...(propApiVersion ? { url: getApiUrl(propApiVersion) } : {}),\n                ...(retries ? { retries } : {}),\n                ...(signal ? { signal } : {}),\n            });\n        }\n        return props;\n    };\n}\n\nexport { generateGetGQLClientParams, generateGetHeaders };\n//# sourceMappingURL=utilities.mjs.map\n"],"names":["CLIENT","GQL_API_ERROR","UNEXPECTED_CONTENT_TYPE_ERROR","NO_DATA_OR_ERRORS_ERROR","CONTENT_TYPES","SDK_VARIANT_HEADER","SDK_VERSION_HEADER","DEFAULT_SDK_VARIANT","DEFAULT_CLIENT_VERSION","RETRIABLE_STATUS_CODES","DEFER_OPERATION_REGEX","BOUNDARY_HEADER_REGEX","HEADER_SEPARATOR","NEWLINE_SEPARATOR","formatErrorMessage","message","client","startsWith","getErrorMessage","error","Error","JSON","stringify","getErrorCause","cause","undefined","combineErrors","dataArray","flatMap","errors","validateRetries","retries","getKeyValueIfValid","key","value","Array","isArray","Object","keys","length","buildDataObjectByPath","path","data","pop","newData","combineObjects","baseObject","newObject","reduce","acc","buildCombinedDataObject","initialDatum","remainingData","generateHttpFetch","clientLogger","customFetchApi","fetch","defaultRetryWaitTime","retriableCodes","httpFetch","async","requestParams","count","maxRetries","nextCount","maxTries","response","type","content","ok","includes","status","deprecationNotice","headers","get","retryAfter","waitTime","Promise","resolve","setTimeout","sleep","parseInt","lastResponse","retryAttempt","createGraphQLClient","url","logger","config","logContent","generateClientLogger","fetchFn","operation","options","variables","overrideHeaders","overrideUrl","overrideRetries","keepalive","signal","body","query","flatHeaders","entries","join","toString","method","generateFetch","request","props","test","statusText","contentType","processJSONResponse","networkStatusCode","generateRequest","requestStream","responseContentType","Symbol","asyncIterator","processedResponse","hasNext","createJsonResponseAsyncIterator","boundaryHeader","match","boundary","getReader","streamBodyIterator","decoder","TextDecoder","chunk","decode","reader","readResult","read","done","cancel","getStreamBodyIterator","responseExtensions","combinedData","streamHasNext","chunkBodies","buffer","textChunk","indexOf","lastBoundaryIndex","lastIndexOf","slice","split","filter","trim","map","readStreamChunk","responseData","getResponseDataFromChunkBodies","find","datum","extensions","responseErrors","validateResponseData","graphQLErrors","createMultipartResponseAsyncInterator","generateRequestStream","json","parse","payload","incremental","incrementalArray","validateApiVersion","currentSupportedApiVersions","apiVersion","versionError","supportedVersion","trimmedApiVersion","supportedApiVersions","console","warn","getQuarterMonth","quarter","month","getPrevousVersion","year","nQuarter","versionQuarter","getCurrentSupportedApiVersions","version","currentVersion","date","Date","getUTCMonth","getUTCFullYear","Math","floor","getCurrentApiVersion","nextVersion","DEFAULT_CONTENT_TYPE","PUBLIC_ACCESS_TOKEN_HEADER","PRIVATE_ACCESS_TOKEN_HEADER","SDK_VARIANT_SOURCE_HEADER","storeDomain","publicAccessToken","privateAccessToken","clientName","storeUrl","trimmedDomain","protocolUrl","URL","protocol","origin","validateDomainAndGetStoreUrl","baseApiVersionValidationParams","validateRequiredAccessTokens","window","validatePrivateAccessTokenUsage","apiUrlFormatter","defaultApiVersion","urlApiVersion","generateApiUrlFormatter","Accept","apiUrl","graphqlClient","getHeaders","customHeaders","generateGetHeaders","getApiUrl","propApiVersion","generateGetApiUrl","getGQLClientParams","push","generateGetGQLClientParams","freeze"],"mappings":"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"}